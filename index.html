<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="css/normalize.css" />
        <link rel="stylesheet" href="css/main.css" />
        <link rel="stylesheet" href="css/singular.css" />
		<link rel="stylesheet" href="js/vendor/prismjs/prism.css" />
		
        <script src="js/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body class="language-markup">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

		<img src="img/singular.png" style="max-width:100%;" />

        <p>Singular provides a simple, yet powerful two-way data binding layer for HTML5 and Javascript. It is similar in many ways to
		Google's <a href="http://angularjs.org/">Angular</a> framework, but takes a more direct, easier-to-use approach to the problem.
		Singular is designed to make it easy to gradually retrofit existing "non-angular" style Javascript projects to using two way
		data binding.</p>

		<p>Javascript data binding is all about abstracting the "juice" (the data, as provided by the user or a web service) into a singular
		data store from which you build your views. The views will "hook" the nestable attributes in the data store, so that any changes to
		them will be reflected in the view. Building your application this way helps to better manage bandwidth and enforce a stronger
		separation of concerns. These are all great things for web apps. Singular gives you a markup-based API, a simple Javascript API, and
		an extension mechanism for accomplishing this model in your apps.</p>

		<p>All Singular pages have at least one model, called window.$appModel. You can use the box in the upper right hand corner to
			explore the $appModel of this page, and make changes. Every change you make to a linked attribute should be reflected in this page.</p>
		<div style="float:right">
			<pre><code>
&lt;input type="text" sg:model="yourName" />&lt;br/>
&lt;div sg:visible="yourName != ''">
	Oh, hello there &lt;span sg:model="yourName">&lt;/span>!
&lt;/div>
			</code></pre>
		</div>

		<h2>sg:model, sg:visible</h2>

		What's your name? <input type="text" sg:model="yourName" placeholder="Type your name here." /><br/>
		<div sg:visible="yourName != ''">
			Oh, hello there <span sg:model="yourName"></span>!
		</div>

		<div class="language-javascript">
			<p>Singular can create automatic, two-way links between elements and the model data by attaching event handlers on the model
				to update the view, and when applicable, the view to update the model.
			If you do not pass a model when calling <code>$().singular()</code>, the global, top-level
			<code>window.$appModel</code> is used. A model may have a parent model, in which it also has an attribute path associated with it
			that acts as a prefix, so that such a "sub-model" refers to a small sub-branch of the overall model. For instance, one might create
			a submodel under <code>library.songs[2]</code>, and then use that model with the markup API or directly to reference attributes of
			<code>library.songs[2]</code> such as <code>name</code> or <code>duration</code>. You may use, e.g., <code>$appModel.use('library.songs[2]')</code>
			as a shortcut to create sub-models.</p>

			<p>Unless you intervene, all top-level <code>SingularModel</code> instances inherit from <code>$appModel</code>. Any number of models
			may inherit from any other model as a sub-model.
			Models have an infinite number of model attributes, which each can have subattributes etc., creating
			a deep keyed tree, just like any other Javascript object. In fact, if you've inspected Singular using DevTools or Firebug,
			$appModel.attributes is the top-level model object where all attributes and values live, but you should not modify it except in
			edge cases (like startup, shutdown, or for avoiding change notifications for some reason).
			You do not interact with model objects from Javascript quite
			the same way, but you won't need Javascript to get started.</p>
		</div>

		<p>Singular's markup API is a simple, if battle-hardened convenience layer on top of the SingularModel API. Use <code>$model.get()</code> to
		retrieve an entry respecting model inheritance and fallbacks, use <code>$model.set()</code> to change attribute values while triggering the
		proper change events, use <code>$model.watch</code> to attach a change event to a particular attribute name. The attribute names supported
		by these methods may be any valid identifiers, separated by dots. Additionally, any component of the path may have an array index at the end,
		with a numeric token inside.</p>

		<p>Singular supports watching simple, fast expressions related to model attributes using <code>$model.expr()</code> and
			<code>$model.watchExpr()</code>. These expressions can be used with <code>sg:visible</code>, used to dictate whether
			an element is visible or not. For some class, add sg:transition (with values "slide" or "fade") to apply an animation.
		Singular also offers sg:checked and sg:selected for <code>&lt;input></code> and
		<code>&lt;select></code>, respectively.
		</p>
		<div style="clear:right"></div>


		<div style="float:right">
			<pre><code>
&lt;script>
	$appModel.set('coins', [
		{name:'Penny'},
		{name:'Nickel'},
		{name:'Dime'},
		{name:'Quarter'}
	]);
&lt;/script>

&lt;ul sg:each="coins">
	&lt;li sg:model="name"
	    contenteditable="true">&lt;/li>
&lt;/ul>

&lt;ul sg:each="coins">
	&lt;li sg:model="name"
	    contenteditable="true">&lt;/li>
&lt;/ul>

Add a coin:
&lt;input type="text" class="coinText" />
&lt;button sg:click="$model.add('coins', {name: $('input.coinText').val()});">Add&lt;/button>
			</code></pre>
		</div>

		<h2>sg:each, sg:click</h2>
		<p>Below, we use <code>sg:each</code> to generate markup for each item of an array within the model. In this
		case the array is stored in the <code>'coins'</code> attribute.</p>
		<div style="display:inline-block;width:12em;">
			A list of coins (click to edit)
			<ul sg:each="coins">
				<li sg:model="name" contenteditable="true"></li>
			</ul>
		</div>
		
		<div style="display:inline-block;width:12em;">
			The same list of coins
			<ul sg:each="coins">
				<li sg:model="name" contenteditable="true"></li>
			</ul>
		</div>
		<br/>
		Add a coin: <input type="text" class="coinText" /> <button sg:click="$model.add('coins', {name: $('input.coinText').val()});">Add</button>

		<div style="clear:right"></div>
		
		<div style="float:right">
			<pre><code>&lt;script>
	$appModel.set('level1', { label: 'Level 1',
		level2: { label: 'Level 2',
			level3: { label: 'Level 3' }
		}
	});
&lt;/script>

&lt;div id="-LevelLabel" class="sgTemplate">
	&lt;span sg:model="label">&lt;/span>
		(&lt;span sg:model="@">&lt;/span>.label)
&lt;/div>

&lt;div sg:use="level1">
	&lt;div sg:view="LevelLabel">&lt;/div>
	&lt;div sg:use="level2">
		&lt;div sg:view="LevelLabel">&lt;/div>
		&lt;div sg:use="level3">
			&lt;div sg:view="LevelLabel">&lt;/div>
		&lt;/div>
	&lt;/div>
&lt;/div>
			</code></pre>
		</div>
		
		<h2>sg:use, sg:view, @</h2>
		<p>Add sg:use to modify the base attribute path for references within a section of markup.
			Any Singular references below that element will be relative to the attribute value
			of the sg:use. This behavior is identical to that of a sub-model, and indeed this attribute
			is functionally equivalent to <code>$contextModel.use('attributeValue')</code>. For performance
			reasons however, sg:use does not generate any models. Instead, all models know how to calculate
			the proper prefix based on the sg:use attributes in use around them.</p>
		<p>Use <code>sg:view</code> to create markup from a template that you have previously defined.
			Define a template by giving it an ID and attaching the <code>sgTemplate</code> class. Be sure to include <code>singular.css</code>
			or <code>singular.scss</code> in the page, or elements with <code>.sgTemplate</code> will appear on your page, singular's stylesheet
			hides them.
			<strong>Note:</strong> If there is a
			class with the same name as the view ID, it will be instantiated and attached to the element.
			Finally, Singular is run on the resulting view instance markup. The Singular context will be
			either the context of Singular during the <code>sg:view</code> operation, or a sub-model rooted at the
			value of the <code>sg:model</code> attribute placed next to the <code>sg:view</code> attribute.</p>
		<p><code>@</code> is a special attribute which asks Singular to return the current path, after all parent
			resolution has taken place. It is identical to calling <code>$contextModel.use(pathBeforeAtSign).where()</code>.
			This attribute can be used with <code>$model.get()</code>, even with nested attribute paths like
			<code>$model.get('level1.level2.@')</code> as used here...</p>
		<div id="-LevelLabel" class="sgTemplate">
			<span sg:model="label"></span> (<span sg:model="@"></span>.label)
		</div>
		<div sg:use="level1">
			<div sg:view="LevelLabel"></div>
			<div sg:use="level2">
				<div sg:view="LevelLabel"></div>
				<div sg:use="level3">
					<div sg:view="LevelLabel"></div>
				</div>
			</div>
		</div>

		<div style="clear:right"></div>



		<div style="float:right">
			<pre><code>
&lt;script>
	$appModel.set('coins', [
		{name:'Penny'},
		{name:'Nickel'},
		{name:'Dime'},
		{name:'Quarter'}
	]);
&lt;/script>

&lt;ul id="coinLi" sg:ignore style="display:none;">
	&lt;li sg:model="name" contenteditable="true">&lt;/li>
&lt;/ul>

&lt;ul sg:each="coins" sg:view="coinLi">&lt;/ul>

Add a coin:
&lt;input type="text" class="coinText2" />
&lt;button sg:click="$model.add('coins', {name: $('input.coinText2').val()});">Add&lt;/button>
			</code></pre>
		</div>

		<h2>sg:each + sg:view</h2>
		<p>You can also combine <code>sg:each</code> and <code>sg:view</code> so you can declare your markup elsewhere from where you call 
			<code>sg:each</code>. In this case, we can use it to avoid duplicating the per-item markup for the two identical
			<code>sg:each</code> operations.</p>
		<ul id="coinLi" sg:ignore style="display:none;">
			<li sg:model="name" contenteditable="true"></li>
		</ul>

		<div style="display:inline-block;width:12em;">
			A list of coins (click to edit)
			<ul sg:each="coins" sg:view="coinLi"></ul>
		</div>

		<div style="display:inline-block;width:12em;">
			The same list of coins
			<ul sg:each="coins" sg:view="coinLi"></ul>
		</div>

		<br/>
		Add a coin: <input type="text" class="coinText2" /> <button sg:click="$model.add('coins', {name: $('input.coinText2').val()});">Add</button>

		<div style="clear:right"></div>

		<h2>Attribute Paths</h2>
		<p>Attribute paths are relative references to slots in the data model. Each component in an attribute path is separated by a dot (<code>.</code>).
		Each component is typically an alphanumeric string. They may also contain underscores. The end of each component may also have an array reference
		containing a numeral such as <code>[35]</code> which may be used to access individual array values. Since the model is just a deep Javascript object,
		it is possible to contnue an attribute path beyond what you might normally consider a leaf in the tree, for example:</p>
		<pre><code class="language-javascript">
// prints length of value for attribute aString
console.log($appModel.get('aString.length'));
		</pre></code>
		<p>However, unless you add code to trigger changes on it using <code class="language-javascript">$model.set('aString.length')</code>, 
		<code>sg:model</code> links to paths like <code>aString.length</code> will not stay synchronized for performance and reliability reasons.

		<h2>Markup Reference</h2>
		<p>When called with <code>$().singular()</code>, Singular will perform a single deep search, using all matched query elements as roots. It searches for
		any elements with any <code>sg:*</code> attribute(s) on them. It then processes each <code>sg:*</code> attribute of each element in an order 
		predetermined within the Singular source code. Unsupported attributes are ignored. Certain conditions will cause Singular to ignore attributes. 
		If underneath an element with <code>sg:each</code>, <code>sg:view</code>, or an element matching <code>.sgTemplate</code>, the attribute
		will not be processed. Also, if the value starts with <code>#</code>, the attribute will not be processed. This can be used to comment out
		Singular behaviors, but is actually used by Singular to track which behaviors have been applied to the model and the DOM, preventing Singular
		from processing them again should it be asked to.</p>

		<h3><code>sg:model="model.attribute"</code></h3>
		<p>Syncs the model attribute with the inner HTML of the element with an attached sg:model attribute. If the host element is a non-disabled input, select,
		textarea or or other input, the view will be capable of changing the model. Singular also understands <code>contenteditable="true"</code>, so edits
		made by users on such elements are reflected in all attached model attributes.</p>

		<h3><code>sg:map="attr:model.attribute;..."</code></h3>
		<p>Syncs one or more HTML attributes with corresponding model attributes. The list is styled like a CSS property list, with semicolons between
		pairs, and colons between key and value. The key is the HTML attribute, the value is the model attribute. The final attribute name will be composed
		from the model chain and sg:use declarations above the host element.</p>

		<h3><code>sg:each="model.attribute;..."</code></h3>
		<p>Creates markup beneath the host element corresponding to each item in the array stored in
			the given model attribute. You may pair this with <code>sg:view</code> to load the per-item
			markup from a template from elsewhere in the document. <code>sg:each</code> is always
			processed before directives beneath it.</p>

		<h3><code>sg:visible="expr"</code></h3>
		<p>Make element visible when <code>expr</code> evaluates to <code>true</code>, invisible otherwise.</p>

		<h3><code>sg:checked="expr"</code></h3>
		<p>Make element checked when <code>expr</code> evaluates to <code>true</code>, unchecked otherwise.</p>

		<h3><code>sg:selected="expr"</code></h3>
		<p>Make element selected when <code>expr</code> evaluates to <code>true</code>, unselected otherwise.</p>

		<h3><code>sg:use="namespace"</code></h3>
		<p>Rebase all model references beneath the host element to be relative to the given "namespace". Effectively
		creates a sub-model, allowing you to omit the attribute prefix in your references.</p>

		<h3><code>sg:ignore</code></h3>
		<p>Do not process any Singular directives beneath the host element.</p>

		<h3><code>sg:click="code"</code></h3>
		<p>Execute a click handler with access to $model, which is set to be the current context model.</p>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="js/vendor/jquery-1.8.3.min.js"><\/script>')</script>
		<script src="js/classModel.js"></script>
		<script src="js/singular.js"></script>
        <script src="js/plugins.js"></script>
		<script>
			$appModel.attributes = {
				coins: [
					{name:'Penny'},
					{name:'Nickel'},
					{name:'Dime'},
					{name:'Quarter'}
				],
				level1: {
					label: 'Level 1',
					level2: {
						label: 'Level 2',
						level3: {
							label: 'Level 3'
						}
					},
					level3: {
						label: 'WRONG Level 3'
					}
				},
				level2: {
					label: 'WRONG Level 2'
				},
				level3: {
					label: 'WRONG Level 3'
				}
			};
		</script>
		<script src="js/vendor/prismjs/prism.js"></script>
        <script src="js/main.js"></script>

        <!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
        <script>
            var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
